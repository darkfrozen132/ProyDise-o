package morapack.planificacion;

import morapack.modelo.*;
import morapack.datos.*;
import java.time.LocalTime;
import java.time.format.DateTimeFormatter;
import java.util.*;

/**
 * Planificador temporal con UTC y plazos optimizado para Colony Algorithm V2
 * VERSI√ìN ACTUALIZADA: Condiciones ID√âNTICAS al sistema gen√©tico
 */
public class PlanificadorTemporalColoniaV2New {
    
    // üîß CONFIGURACI√ìN TEMPORAL (ID√âNTICA AL GEN√âTICO)
    private static final int TIEMPO_PREPARACION_MINUTOS = 30;  // Tiempo preparaci√≥n de pedidos
    private static final int MIN_CONEXION_MINUTOS = 30;        // Tiempo m√≠nimo entre conexiones
    private static final int MAX_ESCALAS = 3;                  // M√°ximo 3 escalas
    private static final DateTimeFormatter TIME_FORMATTER = DateTimeFormatter.ofPattern("HH:mm");
    
    // üìä GESTI√ìN DE CAPACIDAD (NUEVA FUNCIONALIDAD)
    private final Map<String, Integer> capacidadUsada; // Capacidad usada por vuelo por d√≠a
    private final List<Vuelo> vuelosDisponibles;
    private final Map<String, List<Vuelo>> vuelosPorOrigen;
    
    public PlanificadorTemporalColoniaV2New(List<Vuelo> vuelos) {
        this.vuelosDisponibles = vuelos;
        this.capacidadUsada = new HashMap<>();
        
        // Indexar vuelos por origen para b√∫squeda eficiente
        this.vuelosPorOrigen = new HashMap<>();
        for (Vuelo vuelo : vuelos) {
            vuelosPorOrigen.computeIfAbsent(vuelo.getOrigen(), k -> new ArrayList<>()).add(vuelo);
        }
    }
    
    /**
     * Configuraci√≥n inicial del planificador
     */
    public void configurar() {
        System.out.println("üöÄ Configurando Planificador Temporal ColoniaV2 con condiciones ID√âNTICAS al Gen√©tico:");
        System.out.println("   - Tiempo preparaci√≥n: 30 minutos");
        System.out.println("   - Tiempo m√≠nimo conexi√≥n: 30 minutos");
        System.out.println("   - M√°ximo escalas: 3");
        System.out.println("   - Gesti√≥n de capacidad: ACTIVADA");
        System.out.println("   - Plazos continentales: 2 d√≠as");
        System.out.println("   - Plazos intercontinentales: 3 d√≠as");
    }
    
    /**
     * Planifica una ruta considerando el tiempo del pedido, UTC y plazos
     * M√âTODO ID√âNTICO AL SISTEMA GEN√âTICO
     */
    public RutaCompleta planificarRutaTemporal(Pedido pedido, String sedeOrigen) {
        String destino = pedido.getAeropuertoDestinoId();
        int cantidad = pedido.getCantidadProductos();
        
        // Validaciones b√°sicas
        if (destino.equals("SPIM") || destino.equals("EBCI") || destino.equals("UBBB")) {
            return null; // No enviar a nuestras propias sedes
        }
        
        if (sedeOrigen.equals(destino)) {
            return null; // Origen = destino no tiene sentido
        }
        
        // üåç CONVERSI√ìN UTC: Convertir hora del pedido a UTC
        LocalTime horaPedidoLocal = LocalTime.of(pedido.getHora(), pedido.getMinuto());
        LocalTime horaPedidoUTC = GestorUTCyContinentesCSV.convertirAUTC(sedeOrigen, horaPedidoLocal);
        
        // ‚è∞ L√ìGICA TEMPORAL: Calcular cu√°ndo puede salir el pedido en UTC
        int minutosDelDiaUTC = horaPedidoUTC.getHour() * 60 + horaPedidoUTC.getMinute();
        int tiempoMinimoSalidaUTC = minutosDelDiaUTC + TIEMPO_PREPARACION_MINUTOS;
        
        System.out.println("üì¶ Planificando pedido " + pedido.getId() + " (ColoniaV2):");
        System.out.printf("   Hora pedido local (%s): %02d:%02d\n", 
            GestorUTCyContinentesCSV.obtenerZonaHoraria(sedeOrigen),
            pedido.getHora(), pedido.getMinuto());
        System.out.printf("   Hora pedido UTC: %s\n", horaPedidoUTC.format(TIME_FORMATTER));
        System.out.printf("   Tiempo m√≠nimo salida UTC: %s\n", formatearTiempo(tiempoMinimoSalidaUTC));
        
        // üìÜ VALIDACI√ìN DE PLAZOS: Verificar plazo m√°ximo permitido
        int plazoMaximo = GestorUTCyContinentesCSV.obtenerPlazoMaximo(sedeOrigen, destino);
        boolean esIntercontinental = !GestorUTCyContinentesCSV.mismosContinentes(sedeOrigen, destino);
        
        System.out.printf("   üåç Ruta: %s (%s) ‚Üí %s (%s)\n", 
            sedeOrigen, GestorUTCyContinentesCSV.obtenerContinente(sedeOrigen),
            destino, GestorUTCyContinentesCSV.obtenerContinente(destino));
        System.out.printf("   üìÜ Tipo: %s (Plazo m√°ximo: %d d√≠as)\n", 
            esIntercontinental ? "INTERCONTINENTAL" : "CONTINENTAL", plazoMaximo);
        
        // üåô L√ìGICA NOCTURNA: Si es muy tarde, considerar vuelos del d√≠a siguiente
        boolean esNocturno = horaPedidoUTC.getHour() >= 22 || horaPedidoUTC.getHour() < 6;
        if (esNocturno) {
            System.out.println("   üåô Pedido nocturno detectado (UTC)");
        }
        
        return construirRutaTemporalConPlazos(sedeOrigen, destino, cantidad, 
                                            tiempoMinimoSalidaUTC, new HashSet<>(), 
                                            pedido.getDia(), esNocturno, plazoMaximo, 
                                            horaPedidoUTC, pedido.getDia());
    }
    
    /**
     * Construye una ruta temporal considerando plazos m√°ximos
     * IMPLEMENTACI√ìN ID√âNTICA AL SISTEMA GEN√âTICO
     */
    private RutaCompleta construirRutaTemporalConPlazos(String origen, String destino, int cantidad,
                                                      int tiempoMinimo, Set<String> visitados, 
                                                      int diaInicial, boolean esNocturno, int plazoMaximo,
                                                      LocalTime horaPedidoUTC, int diaPedido) {
        
        // Prevenir ciclos infinitos
        if (visitados.contains(origen) || visitados.size() >= MAX_ESCALAS) {
            return null;
        }
        
        visitados.add(origen);
        
        // Buscar vuelos desde el origen
        List<Vuelo> vuelosDesdeOrigen = vuelosPorOrigen.get(origen);
        if (vuelosDesdeOrigen == null || vuelosDesdeOrigen.isEmpty()) {
            return null;
        }
        
        // üéØ B√öSQUEDA DIRECTA: Buscar vuelo directo al destino
        for (Vuelo vuelo : vuelosDesdeOrigen) {
            if (vuelo.getDestino().equals(destino)) {
                
                // Convertir horarios del vuelo a UTC
                LocalTime horaSalidaLocal = LocalTime.parse(vuelo.getHoraSalida());
                LocalTime horaLlegadaLocal = LocalTime.parse(vuelo.getHoraLlegada());
                
                LocalTime horaSalidaUTC = GestorUTCyContinentesCSV.convertirAUTC(origen, horaSalidaLocal);
                LocalTime horaLlegadaUTC = GestorUTCyContinentesCSV.convertirAUTC(destino, horaLlegadaLocal);
                
                if (esVueloDisponibleEnTiempoUTC(vuelo, tiempoMinimo, cantidad, diaInicial, esNocturno)) {
                    
                    // üìÜ VALIDAR PLAZO: Verificar que la entrega est√© dentro del plazo
                    int diaLlegada = calcularDiaLlegada(diaInicial, horaSalidaUTC, horaLlegadaUTC, esNocturno);
                    
                    boolean cumplePlazo = GestorUTCyContinentesCSV.validarPlazoRuta(
                        origen, destino, horaPedidoUTC, diaPedido, horaLlegadaUTC, diaLlegada
                    );
                    
                    if (!cumplePlazo) {
                        System.out.printf("   ‚ùå Vuelo directo excede plazo: %s‚Üí%s\n", origen, destino);
                        continue; // Buscar otra opci√≥n
                    }
                    
                    System.out.printf("     ‚úÖ Vuelo %s %s‚Üí%s (Cap: %d/%d, Paquetes: %d)\n", 
                              vuelo.getHoraSalida(), origen, destino, 
                              vuelo.getCapacidad(), vuelo.getCapacidad(), cantidad);
                    System.out.println("   ‚úàÔ∏è Ruta directa encontrada: " + origen + " ‚Üí " + destino);
                    System.out.printf("   üìÜ Entrega en %d d√≠as (dentro del plazo de %d d√≠as)\n", 
                                    GestorUTCyContinentesCSV.calcularDiasTranscurridos(horaPedidoUTC, diaPedido, horaLlegadaUTC, diaLlegada),
                                    plazoMaximo);
                    
                    // Crear ruta directa exitosa
                    RutaCompleta ruta = new RutaCompleta();
                    ruta.agregarVuelo(vuelo);
                    ruta.setTipoRuta("DIRECTO");
                    
                    // Actualizar capacidad usada
                    String claveVuelo = vuelo.getOrigen() + "-" + vuelo.getDestino() + "-" + vuelo.getHoraSalida() + "-" + diaInicial;
                    capacidadUsada.merge(claveVuelo, cantidad, Integer::sum);
                    
                    return ruta;
                }
            }
        }
        
        // üîÑ B√öSQUEDA CON ESCALAS: Si no hay vuelo directo, buscar con conexiones
        for (Vuelo vuelo : vuelosDesdeOrigen) {
            String aeropuertoConexion = vuelo.getDestino();
            
            // No hacer escala en el destino final ni en el origen
            if (aeropuertoConexion.equals(destino) || aeropuertoConexion.equals(origen)) {
                continue;
            }
            
            if (esVueloDisponibleEnTiempoUTC(vuelo, tiempoMinimo, cantidad, diaInicial, esNocturno)) {
                
                // Calcular tiempo de llegada a la escala para la conexi√≥n
                LocalTime horaLlegadaEscala = LocalTime.parse(vuelo.getHoraLlegada());
                LocalTime horaLlegadaEscalaUTC = GestorUTCyContinentesCSV.convertirAUTC(aeropuertoConexion, horaLlegadaEscala);
                
                int tiempoLlegadaEscala = horaLlegadaEscalaUTC.getHour() * 60 + horaLlegadaEscalaUTC.getMinute();
                int tiempoMinimoConexion = tiempoLlegadaEscala + MIN_CONEXION_MINUTOS;
                
                int diaConexion = calcularDiaLlegada(diaInicial, 
                    GestorUTCyContinentesCSV.convertirAUTC(origen, LocalTime.parse(vuelo.getHoraSalida())), 
                    horaLlegadaEscalaUTC, esNocturno);
                
                // Validar que la escala no exceda el plazo
                int diasHastaEscala = GestorUTCyContinentesCSV.calcularDiasTranscurridos(
                    horaPedidoUTC, diaPedido, horaLlegadaEscalaUTC, diaConexion
                );
                
                if (diasHastaEscala >= plazoMaximo) {
                    continue; // Esta escala ya excede el plazo
                }
                
                // Buscar recursivamente desde la escala
                Set<String> nuevosVisitados = new HashSet<>(visitados);
                RutaCompleta rutaContinuacion = construirRutaTemporalConPlazos(
                    aeropuertoConexion, destino, cantidad, tiempoMinimoConexion,
                    nuevosVisitados, diaConexion, false, plazoMaximo, horaPedidoUTC, diaPedido
                );
                
                if (rutaContinuacion != null) {
                    System.out.printf("     ‚úÖ Vuelo %s %s‚Üí%s (Cap: %d/%d, Paquetes: %d)\n", 
                              vuelo.getHoraSalida(), origen, aeropuertoConexion, 
                              vuelo.getCapacidad(), vuelo.getCapacidad(), cantidad);
                    System.out.printf("     üîÑ Escala: %s‚Üí%s‚Üí... (%d paquetes)\n", origen, aeropuertoConexion, cantidad);
                    
                    // Crear ruta con escala exitosa
                    RutaCompleta ruta = new RutaCompleta();
                    ruta.agregarVuelo(vuelo);
                    
                    // Agregar vuelos de continuaci√≥n
                    for (Vuelo vueloContinuacion : rutaContinuacion.getVuelos()) {
                        ruta.agregarVuelo(vueloContinuacion);
                    }
                    
                    ruta.setTipoRuta("CON_ESCALAS");
                    for (String escala : rutaContinuacion.getEscalas()) {
                        ruta.getEscalas().add(escala);
                    }
                    ruta.getEscalas().add(aeropuertoConexion);
                    
                    // Actualizar capacidad usada
                    String claveVuelo = vuelo.getOrigen() + "-" + vuelo.getDestino() + "-" + vuelo.getHoraSalida() + "-" + diaInicial;
                    capacidadUsada.merge(claveVuelo, cantidad, Integer::sum);
                    
                    System.out.println("   üîÑ Ruta con escalas encontrada");
                    
                    return ruta;
                }
            }
        }
        
        return null; // No se encontr√≥ ruta
    }
    
    /**
     * Verifica si un vuelo est√° disponible considerando tiempo UTC y capacidad
     * IMPLEMENTACI√ìN ID√âNTICA AL SISTEMA GEN√âTICO
     */
    private boolean esVueloDisponibleEnTiempoUTC(Vuelo vuelo, int tiempoMinimo, int cantidad, int dia, boolean esNocturno) {
        
        // Crear clave √∫nica para el vuelo en un d√≠a espec√≠fico
        String claveVuelo = vuelo.getOrigen() + "-" + vuelo.getDestino() + "-" + vuelo.getHoraSalida() + "-" + dia;
        
        // Verificar capacidad disponible
        int capacidadUsadaActual = capacidadUsada.getOrDefault(claveVuelo, 0);
        int capacidadDisponible = vuelo.getCapacidad() - capacidadUsadaActual;
        
        if (capacidadDisponible < cantidad) {
            return false; // No hay suficiente capacidad
        }
        
        // Convertir hora de salida del vuelo a UTC
        LocalTime horaSalidaLocal = LocalTime.parse(vuelo.getHoraSalida());
        LocalTime horaSalidaUTC = GestorUTCyContinentesCSV.convertirAUTC(vuelo.getOrigen(), horaSalidaLocal);
        
        int tiempoSalidaVueloUTC = horaSalidaUTC.getHour() * 60 + horaSalidaUTC.getMinute();
        
        // Verificar si el vuelo sale despu√©s del tiempo m√≠nimo (l√≥gica diaria repetitiva)
        return tiempoSalidaVueloUTC >= tiempoMinimo || esNocturno;
    }
    
    /**
     * Calcula el d√≠a de llegada considerando vuelos nocturnos
     */
    private int calcularDiaLlegada(int diaSalida, LocalTime horaSalida, LocalTime horaLlegada, boolean esNocturno) {
        if (horaLlegada.isBefore(horaSalida)) {
            return diaSalida + 1; // Llega al d√≠a siguiente
        }
        return diaSalida; // Llega el mismo d√≠a
    }
    
    /**
     * Formatea tiempo en minutos a formato HH:mm
     */
    private String formatearTiempo(int minutos) {
        int horas = minutos / 60;
        int mins = minutos % 60;
        return String.format("%02d:%02d", horas % 24, mins);
    }
}
